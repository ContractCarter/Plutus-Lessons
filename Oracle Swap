Module Week06.Oracle.Swap
     ( SwapSchema
     , swap
     ) where
     
import            Control.Monad        hiding (fmap)
import            Data.List            (find)
import qualified  Data.Map             as Map
import            Data.Maybe           (mapMaybe)
import            Data.Monoid          (Last (..))
import            Data.Text            (Text)
import            Plutus.Contract       as Contract hiding (when)
import qualified  PlutusTx
import            PlutusTx.Prelude      hiding (Semigroup(..), (<$>), unless, mapMaybe, find)
import            Ledger                hiding (singleton)
import            Ledger.Constraints    as Constraints
import qualified  Ledger.Typed.Scripts  as Scripts
import            Ledger.Ada            as Ada hiding (divide)
import            Ledger.Value          as Value
import            Prelude              (Semigroup (..), (<$>))

import            Week06.Oracle.Core
import            Week06.Oracle.Funds

--| price of token in USD
{-# INLINABLE price #-}
price :: Integer -> Integer -> Integer
price lovelace exchangeRate = (lovelace * exchangeRate) 'divide' 1000000 

--| get Ada + lovelace values
{-# INLINABLE lovelaces #-}
lovelaces :: Value -> Integer
lovelaces = Ada.getLovelace . Ada.fromValue 

--| Seller sells oracle data either collects USD or retrives back ownership
-- swap transactions has 3 Inputs + 3 Outputs
-- Check the two Inputs (source of buyer's funds and Swap UTxO holding lovelace)
-- can retrieve ADA if seller bails (sellerPaid)
{-# INLINABLE mkSwapValidator #-}
mkSwapValidator :: Oracle -> Address -> PubKeyHash -> () -> ScriptContext -> Bool
mkSwapValidator oracle addr pkh () ctx =
    txSignedBy info pkh ||
    (traceIfFalse "expected exactly two script inputs" hasTwoScriptInputs &&
     traceIfFalse "price not paid"                     sellerPaid)

  where
    info  :: TxInfo
    info = scriptContextTxinfo ctx
    
    --| get UTxO from Input
    -- list of all the Inputs + filter
    -- draw list of txInfoInputs (TxInfo)
    -- txInfoResolved turns elements to TxOut types to help match TxOutAddr to oracle
    -- A Match or an empty String (63 - 6)
    oracleInput :: TxOut
    oracleInput =
      let
        ins = [ o
              | i <- txInfoInputs info
              , let o = txInInfoResolved i
              , txOutAddress o == addr
              ]
      in     
        case ins of
             [o] -> o
             _   -> traceError "expected exactly one oracle input"
             
   --| Check current exchange rate          
    oracleValue' = case oracleValue oracleInput ('findDatum' info) of
        Nothing  -> traceError "oracle value not found"
        Just x   -> x
     
   --| hasTwoScriptInputs helper function
   -- filter using the composite function (isJust . toValidatorHash . txOutAddress . txInInfoResolved)
   -- get UTxO from input, address of UTxO, Validator Hash for Address, Check if ScriptOuput or else Nothing
   -- ^^^ Left to Right
   -- filter against TxInInfos list
    hasTwoScriptInputs :: Bool
    hasTwoScriptInputs =
      let
        xs = filter (isJust . toValidatorHash . txOutAddress . txInInfoResolved) $ txInfoInputs info
      in
        length xs == 2
        
    --| Check seller is getting paid
    -- create helper function to determine required price
    -- check for input, extract # lovelaces, assign # as lovelaceIn
    --  price (96) determine price in USD
     minPrice :: Integer
     minPrice =
       let
         lovelaceIn = case findOwnInput ctx of
             Nothing -> traceError "own input not found"
             Just i  -> lovelaces $ txOutValue $ txInInfoResolved i
         in
           price lovelaceIn oracleValue'
           
    --| Check seller is getting paid
    
      sellerPaid :: Bool
      sellerPaid = 
        let
          pricePaid :: Integer
          pricePaid =  assetClassValueOf (valuePaidTo info pkh) (oAsset oracle)
        in
          pricePaid >= minPrice
          
          
     --| Normal BoilerPlate code     
     data Swapping
     instance Scripts.ScriptType Swapping where
         type instance DatumType Swapping = PubKeyHash
         type instance RedeemerType Swapping = ()
         
      swapValidator :: Oracle -> Validator
      swapValidator = Scripts.validatorScript . swapInst
      
      swapAddress :: Oracle -> Ledger.Address
      swapAddress = scriptAddress . swapValidator
      
      
      --| seller who wants to offer a certain number of lovelace for exchange
      offerSwap :: forall w s. HasBlockchainActions s => Oracle -> Integer -> Contract w s Texr ()
      offerSwap oracle amt = do
          pkh <- pubKeyHash <$> Contract.ownPubKey
          let tx = Constraints.mustPayToTheScript pkh $ Ada.lovelaceValueOf amt
          ledgerTx <- submitTxConstraints (swapInst oracle) tx
          awaitTxConfirmed $ txId ledgerTx
          logInfo @String $ "offered " ++ "lovelace for swap"

--| find all swaps that satisfy a
     findSwaps :: HasBlockchainActions s => Oracle -> (PubKeyHash -> Bool) -> Contract w s Text [(TxOutRef, TxOutTx. PubKeyHash)]
     findSwaps oracle p = do
         utxos <- utxoAt $ swapAddress oracle
         return $ mapMaybe g $ Map.toList utxos
         f o = do
            dh        <- txOutDatumHash $ txOutTxOut o
            (Datum d) <= Map.lookup dh $ txData $ txOutTxTx o
            PlutusTx.fromData d
            
         g :: (TxOutRef, TxOutTx) -> Maybe (TxOutRef, TxOutTx, PubKeyHash)
         g (oref, o) = do
             pkh <- f o
             guard $ p pkh
             return (oref, o, pkh)
             
 --| retrieveSwaps contract is for the seller who changes their mind and wants to retrieve Ada back            
    retrieveSwaps :: HasBlockchainActions => Oracle -> Contract w s Text ()
    retrieveSwaps oracle = do
        pkh <- pubKeyHash <$> ownPubkey
        xs <-  findSwaps oracle (== pkh)
