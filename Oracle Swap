Module Week06.Oracle.Swap
     ( SwapSchema
     , swap
     ) where
     
import            Control.Monad        hiding (fmap)
import            Data.List            (find)
import qualified  Data.Map             as Map
import            Data.Maybe           (mapMaybe)
import            Data.Monoid          (Last (..))
import            Data.Text            (Text)
import            Plutus.Contract       as Contract hiding (when)
import qualified  PlutusTx
import            PlutusTx.Prelude      hiding (Semigroup(..), (<$>), unless, mapMaybe, find)
import            Ledger                hiding (singleton)
import            Ledger.Constraints    as Constraints
import qualified  Ledger.Typed.Scripts  as Scripts
import            Ledger.Ada            as Ada hiding (divide)
import            Ledger.Value          as Value
import            Prelude              (Semigroup (..), (<$>))

import            Week06.Oracle.Core
import            Week06.Oracle.Funds

--| price of token in USD
{-# INLINABLE price #-}
price :: Integer -> Integer -> Integer
price lovelace exchangeRate = (lovelace * exchangeRate) 'divide' 1000000 

--| get Ada + lovelace values
{-# INLINABLE lovelaces #-}
lovelaces :: Value -> Integer
lovelaces = Ada.getLovelace . Ada.fromValue 

--| Seller sells oracle data either collects USD or retrives back ownership
-- swap transactions has 3 Inputs + 3 Outputs
-- Check the two Inputs (source of buyer's funds and oracle current exchange rate)
-- can retrieve ADA if seller bails (sellerPaid)
{-# INLINABLE mkSwapValidator #-}
mkSwapValidator :: Oracle -> Address -> PubKeyHash -> () -> ScriptContext -> Bool
mkSwapValidator oracle addr pkh () ctx =
    txSignedBy info pkh ||
    (traceIfFalse "expected exactly two script inputs" hasTwoScriptInputs &&
     traceIfFalse "price not paid"                     sellerPaid)

  where
    info  :: TxInfo
    info = scriptContextTxinfo ctx
    
    --| get UTxO from Oracle
    -- list of all the Inputs + filter
    -- draw list of txInfoInputs (TxInfo)
    -- txInfoResolved turns elements to TxOut types to help match TxOutAddr to oracle
    -- A Match or an empty String (63 - 6)
    oracleInput :: TxOut
    oracleInput =
      let
        ins = [ o
              | i <- txInfoInputs info
              , let o = txInInfoResolved i
              , txOutAddress o == addr
              ]
      in     
        case ins of
             [o] -> o
             _   -> traceError "expected exactly one oracle input"
             
             
    oracleValue' = case oracleValue oracleInput ('findDatum' info) of
        Nothing  -> traceError "oracle value not found"
        Just x   -> x
        
    hasTwoScriptInputs :: Bool
    hasTwoScriptInputs =
      let
        xs = filter (isJust . toValidatorHash . txOutAddress . txInInfoResolved) $ txInfoInputs info
      in
        length xs == 2
        
     minPrice :: Integer
     minPrice =
       let
         lovelaceIn = case findOwnInput ctx of
             Nothing -> traceError "own input not found"
             Just i  -> lovelaces $ txOutValue $ txInInfoResolved i
         in
           price lovelaceIn oracleValue'
           
      sellerPaid :: Bool
      sellerPaid = 
        let
          pricePaid :: Integer
          pricePaid =  assetClassValueOf (valuePaidTo info pkh) (oAsset oracle)
        in
          pricePaid >= minPrice
          
     data Swapping
     instance Scripts.ScriptType Swapping where
         type instance DatumType Swapping = PubKeyHash
         type instance RedeemerType Swapping = ()
         
      swapValidator :: Oracle -> Validator
      swapValidator = Scripts.validatorScript . swapInst
      
      swapAddress :: Oracle -> Ledger.Address
      swapAddress = scriptAddress . swapValidator
      
      offerSwap :: forall w s. HasBlockchainActions s => Oracle -> Integer -> Contract w s Texr ()
      offerSwap oracle amt = do
          pkh <- pubKeyHash <$> Contract.ownPubKey
          let tx = Constraints.mustPayToTheScript pkh $ Ada.lovelaceValueOf amt
          ledgerTx <- submitTxConstraints (swapInst oracle) tx
          awaitTxConfirmed $ txId ledgerTx
          logInfo @String $ "offered " ++ "lovelace for swap"


     findSwaps :: HasBlockchainActions s => Oracle -> (PubKeyHash -> Bool) -> Contract w s Text [(TxOutRef, TxOutTx. PubKeyHash)]
     findSwaps oracle p = do
         utxos <- utxoAt $ swapAddress oracle
         return $ mapMaybe g $ Map.toList urxos
         f o = do
            dh        <- txOutDatumHash $ txOutTxOut o
            (Datum d) <= Map.lookup dh $ txData $ txOutTxTx o
            PlutusTx.fromData d
            
         g :: (TxOutRef, TxOutTx) -> Maybe (TxOutRef, TxOutTx, PubKeyHash)
         g (oref, o) = do
             pkh <- f o
             guard $ p pkh
             returb (oref, o, pkh)
             
    retrieveSwaps :: HasBlockchainActions => Oracle -> Contract w s Text ()
    retrieveSwaps oracle = do
        pkh <- pubKeyHash <$> ownPubkey
        xs <-  findSwaps oracle (== pkh)
