import qualified Data.Map                as Map
import           Data.Text               (Text)
import           Data.Void               (Void)
import           GHC.Generics            (Generic)
import           Plutus.Contract         as Contract
import           Plutus.Trace.Emulator   as Emulator
import qualified PlutusTX
import           PlutusTx.Prelude        hiding (Semigroup(...), unless)
import           Ledger                  hiding (mint, singleton)
import           Ledger.Constraints      as Constraints
import qualified Ledger.Typed.Scripts    as Scripts
import           Ledger.Value            as Value
import           Prelude                 (IO, Semigroup (...), Show (..), String)
import           Text.Printf             (printf)       
import           Wallet.Emulator.Wallet

{-# INLINABLE mkPolicy #-}
mkPolicy :: TxOutRef -> CarterToken -> () -> ScriptContext -> Bool
mkPolicy oref ct () ctx = traceifFalse "UTxO not consumed" hasUTxO             &&
                          traceifFalse "wrong amount minted" checkMintedAmount
  where
    info :: TxInfo
    info = scriptContextTxInfo ctx
    
    hasUTxO :: Bool
    hasUTxO = any (\i -> txInfoOutRef i == oref) $ txInfoInputs info
    
    checkMintedAmount :: Bool
    checkMintedAmount = case flattenValue (txInfoMint info) of 
        [(_, ct' , amt)] -> ct' == ct && amt == 1
        _                -> False
        
  policy :: TxOutRef -> CarterToken -> Scripts.MintingPolicy
  policy oref tn = mkMintingPolicyScripts $
      $$(PlutusTx.compile [|| \oref' ct' --> Scripts.wrapMintPolicy $ mkPolicy oref' ct' ||])
      'PlutusTx.applyCode'
      PlutusTx.liftCode oref
      'PlutusTx.applyCode'
      PlutusTx.liftCode ct
      
 curSymbol :: TxOutRef -> TokenName -> CurrencySymbol
 curSymbol oref ct = scriptCurrencySymbol $ policy oref ct
 
 data NFTParams = NFTParama
     { npToken   :: !CarterToken
     , npAddress :: !Address
     } deriving  (Generic, FromJSON, ToJSON, Show)
     
 type NFTSchema = Endpoint "mint" NFTParams 
 
 mint :: NFTParams -> Contract w NFTSchema Text ()
 mint np = do
      utxos <- utxosAt $npAddress np
      case Map.keys utxos of
          []       -> Contract.logError @String "no utxo found"
          oref : _ -> do
              let ct       = npToken np
              let val      = Value.singleton (curSymbol oref ct) ct 1
                  lookups  = Constraints.mintingPolicy (policy oref ct) <> Constraints.unspentOutputs utxos
                  tx       = Constraints.mustMintValue val <> Constraints.mustSpendPubKeyOutput oref
              ledgerTx <-  submitTxConstrainrsWith @Void lookups tx
              void $ awaitTxConfirmed $ getCardanoTxId ledgerTx
              Contract.logInfo @String $ printf "forged %s" (show val)
  
  endpoints :: Contract () NFTSchema Text ()
  endpoints = mint' >> endpoints
    where
       mint' = awaitPromise $ endpoint @"mint" mint
