import qualified Data.Map                as Map
import           Data.Text               (Text)
import           Data.Void               (Void)
import           GHC.Generics            (Generic)
import           Plutus.Contract         as Contract
import           Plutus.Trace.Emulator   as Emulator
import qualified PlutusTX
import           PlutusTx.Prelude        hiding (Semigroup(...), unless)
import           Ledger                  hiding (mint, singleton)
import           Ledger.Constraints      as Constraints
import qualified Ledger.Typed.Scripts    as Scripts
import           Ledger.Value            as Value
import           Prelude                 (IO, Semigroup (...), Show (..), String)
import           Text.Printf             (printf)       
import           Wallet.Emulator.Wallet

{-# INLINABLE mkPolicy #-}
--| References the Output, Token Name
-- Check Consumed UTXO + Check Mint "Once"
mkPolicy :: TxOutRef -> CarterToken -> () -> ScriptContext -> Bool
mkPolicy oref ct () ctx = traceifFalse "UTxO not consumed" hasUTxO             &&
                          traceifFalse "wrong amount minted" checkMintedAmount
  where
    info :: TxInfo
    info = scriptContextTxInfo ctx
    --| Check if Input consumes this Output
    hasUTxO :: Bool
    hasUTxO = any (\i -> txInfoOutRef i == oref) $ txInfoInputs info
    
    --| Check TokenName + Amount minted (1)
    checkMintedAmount :: Bool
    checkMintedAmount = case flattenValue (txInfoMint info) of 
        [(_, ct' , amt)] -> ct' == ct && amt == 1
        _                -> False
  --|Compile Policy Script with 'oref' & 'ct'
  policy :: TxOutRef -> CarterToken -> Scripts.MintingPolicy
  policy oref ct = mkMintingPolicyScripts $
      $$(PlutusTx.compile [|| \oref' ct' --> Scripts.wrapMintPolicy $ mkPolicy oref' ct' ||])
      'PlutusTx.applyCode'
      PlutusTx.liftCode oref
      'PlutusTx.applyCode'
      PlutusTx.liftCode ct
      
 curSymbol :: TxOutRef -> TokenName -> CurrencySymbol
 curSymbol oref ct = scriptCurrencySymbol $ policy oref ct]
 
 --| Off-chain code allows endpoints to mint the NFT
 data NFTParams = NFTParama
     { npToken   :: !CarterToken
     , npAddress :: !Address
     } deriving  (Generic, FromJSON, ToJSON, Show)
     
 type NFTSchema = Endpoint "mint" NFTParams 
 
 mint :: NFTParams -> Contract w NFTSchema Text ()
 mint np = do
      utxos <- utxosAt $npAddress np
      case Map.keys utxos of
          []       -> Contract.logError @String "no utxo found"
          oref : _ -> do
              let ct       = npToken np
              let val      = Value.singleton (curSymbol oref ct) ct 1
                  lookups  = Constraints.mintingPolicy (policy oref ct) <> Constraints.unspentOutputs utxos
                  tx       = Constraints.mustMintValue val <> Constraints.mustSpendPubKeyOutput oref
              ledgerTx <-  submitTxConstrainrsWith @Void lookups tx
              void $ awaitTxConfirmed $ getCardanoTxId ledgerTx
              Contract.logInfo @String $ printf "forged %s" (show val)
  
  endpoints :: Contract () NFTSchema Text ()
  endpoints = mint' >> endpoints
    where
       mint' = awaitPromise $ endpoint @"mint" mint
