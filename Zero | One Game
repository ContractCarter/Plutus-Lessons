--| define data type Game + use parameters
-- players define by public key
-- # of lovelace to stake 
-- Two slots (gPlayDeadline = make a move) + (gRevealDeadline = show how u won)
-- gToken = Arbitrary NFT to identify UTXO 

data Game = Game
    { gFirst          :: !PubKeyHash
    , gSecond         :: !PubKeyHash
    , gStake          :: !Integer
    , gPlayDeadline   :: !Slot
    , gRevealDeadline :: !Slot
    , gToken          :: !AssetClass
    } deriving (Show, Generic, FromJSON, ToJSON, Prelude.Eq, Prelude.Ord)

--| Next, we define the two moves that the players can make (Zero & One)
-- need Plutus Eq for the instance,
-- Inlinable pragma on Plutus Eq for the GameChoice
data GameChoice = Zero | One
    deriving (Show, Generic, FromJSON, ToJSON, ToSchema, Prelude.Eq, Prelude.Ord)

instance Eq GameChoice where
    {-# INLINABLE (==) #-}
    Zero == Zero = True
    One  == One  = True
    _    == _    = False

--| For state, we will use a type called GameDatum.
-- ByteString is the hash that the first player submits
-- Maybe GameChoice is either Just the move of the second player, or Nothing
 data GameDatum = GameDatum Bytestring (Maybe GameChoice)
 deriving Show
 
 instance Eq GameDatum where
 {-# INLINABLE (==) #-}
 GameDatum bs mc == GameDatum bs' mc' = (bs == bs') && (mc == mc')

--| Redeemer data type
-- Play second player makes a move
-- Reveals shows 1st players encrypted choice
-- Claim shows if 1st or 2nd won based on the play and reveal deadline

 data GameRedeemer = Play GameChoice | Reveal ByteString | ClaimFirst | ClaimSecond
    deriving Show
    
--| helper function of lovelace values    
 
 lovelaces :: Value -> Integer 
 lovelaces = Ada.getLovelace . Ada.fromValue
 
--| helper function of gameDatum
--| Maybe Monad bind caputures effects of getting Datum Hash
-- Output has a Datum, succeeds get Datum Hash (dh)
-- Datum Hash turns into Datum, succeeds get d
-- Datum (d) Maybe turns into GameDatum

gameDatum :: TxOut -> (DatumHash -> Maybe Datum) -> Maybe GameDatum
gameDatum o f = do
    dh        <- txOutDatum o
    Datum d   <- f dh
    PlutusTx.fromData d
    
    
--| Core business logic mkGameValidator 
mkGameValidator :: Game -> ByteString -> ByteString -> GameDatum -> GameRedeemer -> ScriptContext -> Bool
mkGameValidator game bsZero' bsOne' dat red ctx =


    traceIfFalse "token missing from input" (assetClassValueOf (txOutValue ownInput) (gToken game) == 1) &&
    case (dat, red) of
        (GameDatum bs Nothing, Play c) -> 
             traceIfFalse "not signed by second player"  (txSigneBy info (gSecond game))                                     &&
             traceIfFalse "first player's stake missing" (lovelaces (txOutValue ownInput) == gStake game)                    &&
             traceIfFalse "second player's stake missing (lovelaces (txOutValue ownOutput) == (2 * gstake game))             &&
             traceIfFalse "wrong output datum"           (outputDatum == GameDatum bs (Just c))                              &&
             traceIfFalse "missed deadline"              (to (gPlayDeadline game) 'contains' txInfoValidRange info)          &&
             traceIfFalse "token missing from output"    (assetClassValueOf (txOutValue ownOutput) (gToken game) == 1)       
