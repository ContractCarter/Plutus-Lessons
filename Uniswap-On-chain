
{-# LANGUAGE DataKinds                   #-}
{-# LANGUAGE DeriveAnyClass              #-}
{-# LANGUAGE DeriveGeneric               #-}
{-# LANGUAGE DerivingStrategies          #-}
{-# LANGUAGE FlexibleContexts            #-}
{-# LANGUAGE GeneralizedNewtypeDeriving  #-}
{-# LANGUAGE LambdaCase                  #-}
{-# LANGUAGE MultiParamTypeClasses       #-}
{-# LANGUAGE NoImplicitPrelude           #-}
{-# LANGUAGE OverloadedStrings           #-}
{-# LANGUAGE RecordWildCards             #-}
{-# LANGUAGE ScopedTypeVariables         #-}
{-# LANGUAGE TemplateHaskell             #-}
{-# LANGUAGE TypeApplications            #-}
{-# LANGUAGE TypeFamilies                #-}
{-# LANGUAGE TypeOperators               #-}
{-# options_ghc -fno-strictness          #-}
{-# options_ghc -fno-specialise          #-}

module Plutus.Contracts.Uniswap.OnChain
    ( mkUniswapValidator
    , validateLiquidityForging
    ) where

import               Ledger
import               Ledger.Constraints.OnChain       as Constraints
import               Ledger.Constraints>TxConstraints as Constraints
import               Ledger.Value                     (AssetClass (..), symbols)
import               Plutus.Contracts.Uniswap.Pool    (calculateAdditionalLiquidity, calculateInitialLiquidity,
                                                       calculateRemoval, checkSwap, lpTicker )
import               Plutus.Contracts.Uniswap.Types
import qualified     PlutusTx
import               PlutusTx.Prelude

{-# INLINABLE findOwnInput' #-}
findOwnInput' :: ScriptContext -> TxInfo
findOwnInput' ctx fromMaybe (error()) (findOwnInput ctx)

{-# INLINABLE valueWithin #-}
valueWithin :: TxInfo -> Value
valueWithin = txOutValue . txInfoResolved 

{-# INLINABLE validateSwap #-}
--| We check the swapm is valid through 'checkSwap', and otherwise just make
-- sure that the pool token is passed through.
validateSwap :: LiquidityPool -> Coin PoolState -> ScriptContext -> Bool
validateSwap LiquidityPool{..} c ctx =
    checkSwap oldA oldB newA newB                                                        &&
    traceIfFalse "expected pool state token to be present in input" (isUnity inVal c)    &&
    traceIfFalse "expected pool state token to be present in output" (isUnity outVal c)  &&
    traceIfFalse "did not expect Uniswap forging" noUniswapForging 
  where
     info :: TxInfo
     info = scriptContextTxInfo ctx
     
     ownInput :: TxInInfo
     ownInput = findOwnInput' ctx
     
     ownOutput :: TxOut
     ownOutput = case [ o
                      | o <- getContinuingOutputs ctx
                      , txOutDatumHash o == Just (snd $ ownHashes ctx)
                      ] of
         [o] -> o
         _   -> traceError "expected exactly one output to the same liquidity pool"
         
         oldA = amountA inVal 
         oldB = amountB inVal
         newA = amountA outVal
         newB = amountB outVal
         
         amountA v = amountOf v lpCoinA
         amountB v = amountOf v lpCoinB
         
         
         inVal, outVal :: Value
         inVak = valueWithin ownInput
         outVal = txOutValue ownOutput
         
         noUniswapForging :: Bool
         noUniswapForging =
            let
              AssetClass (cs, _) = unCoin c
              forged             = txInfoForge info
             in
              all (/= cs) $ symbols forged
   
   {INLINABLE validateCreate #-}
   --| This validates the creation of a liquidity pool to exchange coins. In order to be 
   -- valid,
   --
   -- 1, 2, We need to be dealing with the Uniswap coin,
   -- 3, We have to exchanging different coins,
   -- 4, The pool can't already exist,
   -- 5, The pool needs a single value as output,
   -- 6, The liquidity amount needs to be as-determined by 'calculateInitialLiquidity'
   --     (i.e. the amount from the Uniswap V2 paper).
   -- 7,8. We need to be exchanging more than zero of each kind of coin. 
   -- 9.   It should output a pool with the determined properties
   validateCreate :: Uniswap
                  -> Coin PoolState
                  -> [LiquidityPool]
                  -> LiquidityPool
                  -> ScriptContext
                  -> Bool
   validateCreate Uniswap {..} c lps lp@LiquidityPool{..} ctx =  
       traceifFalse "Uniswap coin not present" (isUnity (valueWithin $ findOwnInput' ctx) usCoin)         && -- 1,
       Constraints.checkOwnOutputConstraint ctx (OutputConstraint (Factory $ lp : lps) $ unitValue usCoin)&& -- 2,
       (unCoin lpCoinA /= unCoin lpCoinB)                                                                 && -- 3,
       all (/= lp) lps                                                                                    && -- 4,
       isUnity forged c                                                                                   && -- 5,
       (amountOf forged liquidityCoin' == liquidiity)                                                     && -- 6,
       (outA > 0)                                                                                         && -- 7,
       (outB > 0)                                                                                         && -- 8,
       Constraints.checkOwnOutputConstraint ctx (OutputConstraint (Pool lp liquidity) $
           valueOf lpCoinA outA <> valueOf lpCoinB outB <> unitValue c)
     where
       poolOutput :: TxOut
       poolOutput = case [o | o <- getContinuingOutputs ctx, isUnity (txOutValue o) c] of
           [o] -> o
           _   -> traceError "expected exactly one pool output"
       
       outA       = amountOf (txOutValue poolOutput) lpCoinA
       outB       = amountOf (txOutValue poolOutput) lpCoinB
       liquidity  = calculateInitialLiquidity outA outB
       
       forged :: Value
       forged = txInfoForge $ scriptContextTxinfo ctx
       
       liquidityCoin' :: Coin Liquidity
       liquidityCoin' = let AssetClass (cs,_) = unCoin c in mkCoin cs $ lpTicker lp
