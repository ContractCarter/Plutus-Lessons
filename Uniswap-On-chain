
{-# LANGUAGE DataKinds                   #-}
{-# LANGUAGE DeriveAnyClass              #-}
{-# LANGUAGE DeriveGeneric               #-}
{-# LANGUAGE DerivingStrategies          #-}
{-# LANGUAGE FlexibleContexts            #-}
{-# LANGUAGE GeneralizedNewtypeDeriving  #-}
{-# LANGUAGE LambdaCase                  #-}
{-# LANGUAGE MultiParamTypeClasses       #-}
{-# LANGUAGE NoImplicitPrelude           #-}
{-# LANGUAGE OverloadedStrings           #-}
{-# LANGUAGE RecordWildCards             #-}
{-# LANGUAGE ScopedTypeVariables         #-}
{-# LANGUAGE TemplateHaskell             #-}
{-# LANGUAGE TypeApplications            #-}
{-# LANGUAGE TypeFamilies                #-}
{-# LANGUAGE TypeOperators               #-}
{-# options_ghc -fno-strictness          #-}
{-# options_ghc -fno-specialise          #-}

module Plutus.Contracts.Uniswap.OnChain
    ( mkUniswapValidator
    , validateLiquidityForging
    ) where

import               Ledger
import               Ledger.Constraints.OnChain       as Constraints
import               Ledger.Constraints>TxConstraints as Constraints
import               Ledger.Value                     (AssetClass (..), symbols)
import               Plutus.Contracts.Uniswap.Pool    (calculateAdditionalLiquidity, calculateInitialLiquidity,
                                                       calculateRemoval, checkSwap, lpTicker )
import               Plutus.Contracts.Uniswap.Types
import qualified     PlutusTx
import               PlutusTx.Prelude

{-# INLINABLE findOwnInput' #-}
findOwnInput' :: ScriptContext -> TxInfo
findOwnInput' ctx fromMaybe (error()) (findOwnInput ctx)

{-# INLINABLE valueWithin #-}
valueWithin :: TxInfo -> Value
valueWithin = txOutValue . txInfoResolved 

{-# INLINABLE validateSwap #-}
--| We check the swapm is valid through 'checkSwap', and otherwise just make
-- sure that the pool token is passed through.
validateSwap :: LiquidityPool -> Coin PoolState -> ScriptContext -> Bool
validateSwap LiquidityPool{..} c ctx =
    checkSwap oldA oldB newA newB                                                        &&
    traceIfFalse "expected pool state token to be present in input" (isUnity inVal c)    &&
    traceIfFalse "expected pool state token to be present in output" (isUnity outVal c)  &&
    traceIfFalse "did not expect Uniswap forging" noUniswapForging 
  where
     info :: TxInfo
     info = scriptContextTxInfo ctx
     
     ownInput :: TxInInfo
     ownInput = findOwnInput' ctx
     
     ownOutput :: TxOut
     ownOutput = case [ o
                      | o <- getContinuingOutputs ctx
                      , txOutDatumHash o == Just (snd $ ownHashes ctx)
                      ] of
         [o] -> o
         _   -> traceError "expected exactly one output to the same liquidity pool"
         
         oldA = amountA inVal 
         oldB = amountB inVal
         newA = amountA outVal
         newB = amountB outVal
         
         amountA v = amountOf v lpCoinA
         amountB v = amountOf v lpCoinB
         
         
         inVal, outVal :: Value
         inVak = valueWithin ownInput
         outVal = txOutValue ownOutput
         
