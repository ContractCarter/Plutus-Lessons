

--| Paramaterize Oracle contract with four fields
--  AssetClass = exchange rate against Ada (usd) 
data Oracle = Oracle
    { oSymbol   :: !CurrencySymbol
    , oOperator :: !PubKeyHash
    , oFee      :: !Integer
    , oAsset    :: !AssetClass
    } deriving (Show, Generic, FromJSON, ToJSON, Prelude.Eq, Prelude.Ord)

PlutusTx.makeLift ''Oracle 

--| define redeemer
data OracleRedeemer = Update | Use
    deriving Show
    
PlutusTx.unstableMakeIsData ''OracleRedeemer
--| helper definitions (3)
--  define NFT asset class, (oAsset = USD)
{-# INLINABLE oracleTokenName #-}
oracleTokenName :: TokenName
oracleTokenName = TokenName emptyByteString

--| OracleAsset identify the NFT, Not oAsset
{-# INLINABLE oracleAsset #-}
oracleAsset :: Oracle -> AssetClass
oracleAsset oracle = AssetClass (oSymbol oracle, oracleTokenName)

--| Maybe Monad bind caputures effects of getting Datum Hash
-- Output has a Datum, succeeds get Datum Hash (dh)
-- Datum Hash turns into Datum, succeeds get d
-- Datum (d) Maybe turns into integer

{-# INLINABLE oracleValue #-}
oracleValue :: TXOut -> (DatumHash -> Maybe Datum) -> Maybe Integer
oracleValue o f = do
    dh      <- txOutDatum o
    Datum d <- f dh
    PlutusTx.fromData d
--| Check if Input + Oracle Output holds the NFT
--  Redeemer Two cases (Update + Use)
{-# INLINABLE mkOracleValidator #-}
mkOracleValidator :: Oracle -> Integer -> OracleRedeemer -> ScriptContext -> Bool
mkOracleValidator oracle x r ctx =
    traceIfFalse "token missing from input"  inputHasToken &&
    traceIfFalse "token missing from output" outputHasToken &&
    case r of
         Update -> traceIfFalse "operator signature missing" (txSignedBy info $ oOperator oracle) &&
                   traceIfFalse "invalid output datum"       validOutputDatum
         Use    -> traceIfFalse "oracle value changed"       (outputDatum == Just x)
                   traceIfFalse "fees not paid"              feesPaid
                   
 --| consume Oracle Output
 where
   info :: TxInfo
   info = scriptContextTxInfo ctx
   
 --| ownInput returns Oracle Output the script is trying to consume
 --  findOwnInput function finds the relevant input
 --  Nothing happens if in a different context(ex. Minting)
--  txInInfoResolved function get TXOut from TxInfo
   ownInput :: TxOut
   ownInput = case findOwnInput ctx of
       Nothing -> traceError "oracle input missing"
       Just i  -> txInInfoResolved i
       
 --|Check if Input token is present
 -- assetClassValueOf function to look for NFT
   inputHasToken :: Bool
   inputHasToken = assetClassValueOf (txOutValue ownInput) (oracleAsset oracle) == 1
   
   -- Find 1 Relevant Oracle Output
   -- returns a list Oracles Outputs
   ownOutput :: TxOut
   ownOutput = case getContinuingOutputs ctx of
        [o] -> o
       _    -> traceError "expected exactly one oracle output"
       
 
 --|Check if Output token is present
 -- assetClassValueOf function to look for NFT
   outputHasToken :: Bool
   outputHasToken = assetClassValueOf (txOutValue ownOutput) (oracleAsset oracle) == 1
   
 --| Datum can arbitrarly change, still be Integer type
 -- OracleValue finds New Output Datum 
   outputDatum :: Maybe Integer
   outputDatum :: oracleValue ownOutput ('findDatum' info)
  
  --|Check if OutputDatum has an Integer
   validOutputDatum ::  Bool
   validOutputDatum = isJust outputDatum
    
  --|Check if fees are paid
  -- Check Oracle Input + Output Values
  -- Output Value greater or == (geq) to Input Value
   feesPaid :: Bool
   feesPaid =
     let
       inVal = txOutValue ownInput
       outVal = txOutValue ownOutput
      in
       outVal 'geq' (inVal <> Ada.lovelaceValueOf (oFee oracle))
       
 data Oracling
 instance Scripts.ScriptType Oracling where
     type instance DatumType Oracling = Integer
     type instance RedeemerType Oracling = OracleRedeemer
     
 oracleInst :: Oracle -> ScriptInstance Oracling
 oracleInst oracle = Scripts.validator @Oracling
     ($$(PlutusTx.compile [|| mkOracleValidator||]) 'PlutusTx.applyCode' PlutusTx.liftCode oracle)
     $$(PlutusTx.compile [|| wrap ||])
    where
      wrap = Scripts.wrapValidator @Integer @OracleRedeemer
      
 oracleValidator :: Oracle -> Validator 
 oracleValidator = Scripts.validatorScript . oracleInst
 
 data OracleParams = OracleParams 
     { opFees    :: !Integer
     , opSymbol  :: !CurrencySymbol
     , opToken   :: !TokenName
     } deriving  (Show, Generic, FromJSON, ToJSON)
     
 --| Could use code in Mint Lesson to Mint NFT
 -- Using this 
 startOracle :: forall w s. HasBlockchainActions s => OracleParams -> Contract w s Text Oracle
 startOracle op = do
     pkh <- pubKeyHash <$> Contract.ownPubKey
     osc <- mapError (pack . show) (forgetContract pkh [(oracleTokenName, 1)] :: Contract w s CurrencyError OneShotCurrency)\
     let cs      = Currency.currencySymbol osc
         oracle  = Oracle
             {  oSymbol   = cs
             ,  oOperator = pkh
             ,  oFee      = opFees op
             ,  oAsset    = AssetClass (opSymbol op, opToken op)
             }
      logInfo @String $started oracle " ++ show oracle        
      
 oracleValidator
