
{-# LANGUAGE DataKinds                          #-}
{-# LANGUAGE DeriveAnyClass                     #-}
{-# LANGUAGE DerivingStrategies                 #-}
{-# LANGUAGE FlexibleContexts                   #-}
{-# LANGUAGE GeneralizeNewtypeDeriving          #-}
{-# LANGUAGE LambdaCase                         #-}
{-# LANGUAGE MultiParamTypeClasses              #-}
{-# LANGUAGE NoImplicitPrelude                  #-}
{-# LANGUAGE OverloadedStrings                  #-}
{-# LANGUAGE RecordWildCards                    #-}
{-# LANGUAGE ScopedTypeVariables                #-}
{-# LANGUAGE TemplateHaskell                    #-}
{-# LANGUAGE TypeApplications                   #-}
{-# LANGUAGE TypeFamilies                       #-}
{-# LANGUAGE TypeOperators                      #-}

module Plutus.Contracts.Uniswap.OffChain
    ( poolStateCoinFromUniswapCurrency, liquidityCoin
    , CreateParams (..)
    , SwapParams (..)
    , CloseParams (..)
    , RemoveParams (..)
    , AddParams (..)
    , UniswapUserSchema, UserContractState (..)
    , UniswapOwnerSchema
    , start, create, add, remove, close, swap, pools
    , ownerEndpoint, userEndpoints
    ) where
    
 import           Control.Monad                      hiding (fmap)  
 import qualified Data.Map                           as Map
 import           Data.Monoid                        (Last (..))
 import           Data.Proxy                         (Proxy (..))
 import           Data.Text                          (Text, pack)
 import           Data.Void                          (Void)
 import           Ledger                             hiding (singleton)
 import           Ledger.Constraints                 as Constraints
 import qualified Ledger.Typed.Scripts               as Scripts
 import           Playground.Contract
 import           Plutus.Contract                    hiding (when)
 import qualified Plutus.Contract.Currency           as Currency
 import           Plutus.Contracts.Uniswap.OnChain   (mkUniswapValidator, validateLiquidityForging)
 import           Plutus.Contracts.Uniswap.Pool
 import           Plutus.Contracts.Uniswap.Types
 import qualified PlutusTx
 import           PlutusTx.Prelude                    hiding (Semigroup (..), dropWhile, flip, unless)
 import           Prelude                             as Haskell (Int, Semigroup (..), String, div, dropWhile, flip, show,
 
 import           Text.Printf                         (printf)
 
 data Uniswapping
 instance Scripts.ScriptType Uniswapping where
     type instance RedeemerType Uniswapping = UniswapAction
     type instance DatumType    Uniswapping = UniswapDatum
 
--| define two Schemas
--  Creates Uniswap Factory
 type UniswapOwnerSchema =
     BlockchainActions
         ./\ Endpoint "start" ()
         
 --|Create and manage Liquidity Pool        
 type UniswapUserSchema = 
     BlockchainActions
         .\/ Endpoint "create" CreateParams
         .\/ Endpoint "swap"   SwapParams
         .\/ Endpoint "close"  CloseParams
         .\/ Endpoint "remove" RemoveParams
         .\/ Endpoint "add"    AddParams
         .\/ Endpoint "pools" ()
         .\/ Endpoint "funds" ()
         .\/ Endpoint "stop"  ()
         
-- | Type of the Uniswap user contract state.
data UserContractState =
      Pools [((Coin A, Amount A), (Coin B, Amount B))]
    | Funds Value
    | Created
    | Swapped
    | Added
    | Removed
    | Close
    | Stopped
    deriving (Show, Generic, FromJSON, ToJSON)
    
--| UniswapTokenName = Factory NFT
-- poolStateTokenName = Liquidity Pool Coins NFT
uniswapTokenName, poolStateTokenName :: TokenName
uniswapTokenName = "Uniswap"
poolStateTokenName = "Pool State"

--| Script Instance Boiler Plate
uniswapInstance :: Uniswap -> Scripts.ScriptInstance Uniswapping
uniswapInstance us = Scripts.validator @Uniswapping
    ($$(PlutusTx.compile [|| mkUniswapValidator ||])
        'PlutusTx.applyCode' PlutusTx.liftCode us
        'PlutusTx.applyCode' PlutusTx.liftCode c)
     $$(PlutusTx.compile [|| wrap ||])
     where
       c :: Coin PoolState
       c = poolStateCoin us
       
       wrap = Scripts.wrapValidator @UniswapDatum @UniswapAction

uniswapScript :: Uniswap -> Validator
uniswapScript = Scripts.validatorScript . uniswapInstance

uniswapAddress :: Uniswap -> Ledger.Address
uniswapAddress = Ledger.scriptAddress . uniswapScript

uniswap :: CurrencySymbol -> Uniswap
uniswap cs = Uniswap $ mkCoin cs uniswapTokenName
 
liquidityPolicy :: Uniswap -> MonetaryPolicy
liquidityPolicy us = mkMonetaryPolicyScript $
    $$(PlutusTx.compile [|| \u t -> Scripts.wrapMonetaryPolicy (validateLiquidityForging u t) ||])
        'PlutusTx.applyCode' PlutusTx.liftCode us
        'PlutusTx.applyCode' PlutusTx.liftCode poolStateTokenName
 
 liquidityCurrency :: Uniswap -> CurrencySymbol
 liquidityCurrency = scriptCurrencySymbol . liquidityPolicy
 
 poolStateCoin :: Uniswap -> Coin PoolState
 poolStateCoin = flip mkCoin poolStateTokenName . liquidityCurrency
 
 --| Gets the 'Coin' used to identity liquidity pools.
 poolStateCoinFromUniswapCurrency :: CurrencySymbol  -- ^ The currency identifying the Uniswap instance.
                                  -> Coin PoolState
 poolStateCoinFromUniswapCurrency = poolStateCoin . uniswap                                 

--| Gets the liquidity token for a given liquidity pool.
liquidityCoin :: CurrencySymbol -- ^ The currency identifying the Uniswap instance.
              -> Coin A         -- ^ One coin in the liquidity pair.
              -> Coin B         -- ^ The other coin in the liquidity pair.
liquidityCoin cs coinA coinB = mkCoin (liquidityCurrency $ uniswap cs) $ lpTicker $ LiquidityPool coinA coinB

--| All parameters for the five endpoints
data CreateParams = CreateParams
    { cpCoinA   :: Coin A       -- ^ One 'Coin' of the liquidity pair
    , cpCoinB   :: Coin B       -- ^ The other 'Coin'
    , cpAmountA :: Amount A     -- ^ The Amount of liquidity for the first 'Coin'
    , cpAmountB :: Amount B     __ ^ The Amount of the second 'Coin' that should be swapped.
    } deriving (Show, Generic, ToJSON, FromJSON, ToSchema)
    
data SwapParams = SwapParams
    { spCoinA   :: Coin A       -- ^ One 'Coin' of the liquidity pair.
    , spCoinB   :: Coin B       -- ^ The other 'Coin'
    , spAmountA :: Amount A     -- ^ The amount the first 'Coin' that should be swapped
    , spAmountB :: Amount B     -- ^ The amount of the second 'Coin' that should be swapped
    } deriving (Show, Generic, ToJSON, FromJSON, ToSchema)

data CloseParams = CloseParams
    { clpCoinA :: Coin A
    , clpCoinB :: Coin B
    }deriving (Show, Generic, ToJSON, FromJSON, ToSchema)

data RemoveParams = RemoveParams
    { rpCoinA :: Coin A
    , rpCoinB :: Coin B
    , rpDiff  :: Amount Liquidity
    } deriving (Show, Generic, TOJSON, FromJSON, ToSchema)
    
data AddParams = AddParams
    { apCoinA   :: Coin A
    , apCoinB   :: Coin B
    , apAmountA :: Amount A
    , apAmountB :: Amount B
    } deriving (Show, Generic, ToJSON, FromJSON, ToSchema)
