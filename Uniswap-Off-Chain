
{-# LANGUAGE DataKinds                          #-}
{-# LANGUAGE DeriveAnyClass                     #-}
{-# LANGUAGE DerivingStrategies                 #-}
{-# LANGUAGE FlexibleContexts                   #-}
{-# LANGUAGE GeneralizeNewtypeDeriving          #-}
{-# LANGUAGE LambdaCase                         #-}
{-# LANGUAGE MultiParamTypeClasses              #-}
{-# LANGUAGE NoImplicitPrelude                  #-}
{-# LANGUAGE OverloadedStrings                  #-}
{-# LANGUAGE RecordWildCards                    #-}
{-# LANGUAGE ScopedTypeVariables                #-}
{-# LANGUAGE TemplateHaskell                    #-}
{-# LANGUAGE TypeApplications                   #-}
{-# LANGUAGE TypeFamilies                       #-}
{-# LANGUAGE TypeOperators                      #-}

module Plutus.Contracts.Uniswap.OffChain
    ( poolStateCoinFromUniswapCurrency, liquidityCoin
    , CreateParams (..)
    , SwapParams (..)
    , CloseParams (..)
    , RemoveParams (..)
    , AddParams (..)
    , UniswapUserSchema, UserContractState (..)
    , UniswapOwnerSchema
    , start, create, add, remove, close, swap, pools
    , ownerEndpoint, userEndpoints
    ) where
    
 import           Control.Monad                      hiding (fmap)  
 import qualified Data.Map                           as Map
 import           Data.Monoid                        (Last (..))
 import           Data.Proxy                         (Proxy (..))
 import           Data.Text                          (Text, pack)
 import           Data.Void                          (Void)
 import           Ledger                             hiding (singleton)
 import           Ledger.Constraints                 as Constraints
 import qualified Ledger.Typed.Scripts               as Scripts
 import           Playground.Contract
 import           Plutus.Contract                    hiding (when)
 import qualified Plutus.Contract.Currency           as Currency
 import           Plutus.Contracts.Uniswap.OnChain   (mkUniswapValidator, validateLiquidityForging)
 import           Plutus.Contracts.Uniswap.Pool
 import           Plutus.Contracts.Uniswap.Types
 import qualified PlutusTx
 import           PlutusTx.Prelude                    hiding (Semigroup (..), dropWhile, flip, unless)
 import           Prelude                             as Haskell (Int, Semigroup (..), String, div, dropWhile, flip, show,
 
 import           Text.Printf                         (printf)
 
 data Uniswapping
 instance Scripts.ScriptType Uniswapping where
     type instance RedeemerType Uniswapping = UniswapAction
     type instance DatumType    Uniswapping = UniswapDatum
 
--| define two Schemas
--  Creates Uniswap Factory
 type UniswapOwnerSchema =
     BlockchainActions
         ./\ Endpoint "start" ()
         
 --|Create and manage Liquidity Pool        
 type UniswapUserSchema = 
     BlockchainActions
         .\/ Endpoint "create" CreateParams
         .\/ Endpoint "swap"   SwapParams
         .\/ Endpoint "close"  CloseParams
         .\/ Endpoint "remove" RemoveParams
         .\/ Endpoint "add"    AddParams
         .\/ Endpoint "pools" ()
         .\/ Endpoint "funds" ()
         .\/ Endpoint "stop"  ()
         
-- | Type of the Uniswap user contract state.
data UserContractState =
      Pools [((Coin A, Amount A), (Coin B, Amount B))]
    | Funds Value
    | Created
    | Swapped
    | Added
    | Removed
    | Close
    | Stopped
    deriving (Show, Generic, FromJSON, ToJSON)
    
--| UniswapTokenName = Factory NFT
-- poolStateTokenName = Liquidity Pool Coins NFT
uniswapTokenName, poolStateTokenName :: TokenName
uniswapTokenName = "Uniswap"
poolStateTokenName = "Pool State"

--| Script Instance Boiler Plate
uniswapInstance :: Uniswap -> Scripts.ScriptInstance Uniswapping
uniswapInstance us = Scripts.validator @Uniswapping
    ($$(PlutusTx.compile [|| mkUniswapValidator ||])
        'PlutusTx.applyCode' PlutusTx.liftCode us
        'PlutusTx.applyCode' PlutusTx.liftCode c)
     $$(PlutusTx.compile [|| wrap ||])
     where
       c :: Coin PoolState
       c = poolStateCoin us
       
       wrap = Scripts.wrapValidator @UniswapDatum @UniswapAction

uniswapScript :: Uniswap -> Validator
uniswapScript = Scripts.validatorScript . uniswapInstance

uniswapAddress :: Uniswap -> Ledger.Address
uniswapAddress = Ledger.scriptAddress . uniswapScript

uniswap :: CurrencySymbol -> Uniswap
uniswap cs = Uniswap $ mkCoin cs uniswapTokenName
 
liquidityPolicy :: Uniswap -> MonetaryPolicy
liquidityPolicy us = mkMonetaryPolicyScript $
    $$(PlutusTx.compile [|| \u t -> Scripts.wrapMonetaryPolicy (validateLiquidityForging u t) ||])
        'PlutusTx.applyCode' PlutusTx.liftCode us
        'PlutusTx.applyCode' PlutusTx.liftCode poolStateTokenName
 
 liquidityCurrency :: Uniswap -> CurrencySymbol
 liquidityCurrency = scriptCurrencySymbol . liquidityPolicy
 
 poolStateCoin :: Uniswap -> Coin PoolState
 poolStateCoin = flip mkCoin poolStateTokenName . liquidityCurrency
 
 --| Gets the 'Coin' used to identity liquidity pools.
 poolStateCoinFromUniswapCurrency :: CurrencySymbol  -- ^ The currency identifying the Uniswap instance.
                                  -> Coin PoolState
 poolStateCoinFromUniswapCurrency = poolStateCoin . uniswap                                 

--| Gets the liquidity token for a given liquidity pool.
liquidityCoin :: CurrencySymbol -- ^ The currency identifying the Uniswap instance.
              -> Coin A         -- ^ One coin in the liquidity pair.
              -> Coin B         -- ^ The other coin in the liquidity pair.
liquidityCoin cs coinA coinB = mkCoin (liquidityCurrency $ uniswap cs) $ lpTicker $ LiquidityPool coinA coinB

--| All parameters for the five endpoints
data CreateParams = CreateParams
    { cpCoinA   :: Coin A       -- ^ One 'Coin' of the liquidity pair
    , cpCoinB   :: Coin B       -- ^ The other 'Coin'
    , cpAmountA :: Amount A     -- ^ The Amount of liquidity for the first 'Coin'
    , cpAmountB :: Amount B     __ ^ The Amount of the second 'Coin' that should be swapped.
    } deriving (Show, Generic, ToJSON, FromJSON, ToSchema)
    
data SwapParams = SwapParams
    { spCoinA   :: Coin A       -- ^ One 'Coin' of the liquidity pair.
    , spCoinB   :: Coin B       -- ^ The other 'Coin'
    , spAmountA :: Amount A     -- ^ The amount the first 'Coin' that should be swapped
    , spAmountB :: Amount B     -- ^ The amount of the second 'Coin' that should be swapped
    } deriving (Show, Generic, ToJSON, FromJSON, ToSchema)

data CloseParams = CloseParams
    { clpCoinA :: Coin A
    , clpCoinB :: Coin B
    }deriving (Show, Generic, ToJSON, FromJSON, ToSchema)

data RemoveParams = RemoveParams
    { rpCoinA :: Coin A
    , rpCoinB :: Coin B
    , rpDiff  :: Amount Liquidity
    } deriving (Show, Generic, TOJSON, FromJSON, ToSchema)
    
data AddParams = AddParams
    { apCoinA   :: Coin A
    , apCoinB   :: Coin B
    , apAmountA :: Amount A
    , apAmountB :: Amount B
    } deriving (Show, Generic, ToJSON, FromJSON, ToSchema)

-- | Creates a Uniswap "factory". This factory will keep track of existing liquidity pools and enforce that there will be at most one liquidity pool
-- for any pair of tokens at any given time.
start :: HasBlockchainActions s => Contract w s Text Uniswap
start = do
     pkh <- pubKeyHash <$> ownPubKey
     cs  <- fmap Currency.currencySymbol $
            mapError (pack . show @Currency.CurrencyError) $
            Currency.forgeContract pkh [(uniswapTokenName, 1)]
     let c    = mkCoin cs uniswapTokenName
         us   = uniswap cs
         inst = uniswapInstance us
         tx   = mustPayToTheScript (Factory []) $ unitValue c
      ledgerTx <- submitTxConstraints inst tx
      void $ awaitTxConfirmed $ txId ledgerTx
      
      logInfo @String $ printf "started Uniswap %s at address %$" (show us) (show $ uniswapAddress us)
      return us
      
  create :: HasBlockchainActions s => Uniswap -> CreateParams -> Contract w s Text ()
  create us CreateParams{..} = do
      when (unCoin cpCoinA == unCoin cpCoinB) $ throwError "coins must be different"
      when (cpAmountA <= 0 || cpAmountB <= 0) $ throwError "amounts must be positive"
       (oref, o, lps) <- findUniswapFactory us
       let liquidity = calculateInitialLiquidity cpAmountA cpAmountB
           lp        = LiquidityPool {lpCoinA = cpCoinA, lpCoinB = cpCoinB}
       let usInst   = uniswapInstance us
           usScript = uniswapScript us
           usDat1   = Factory $ lp : lps
           usDat2   = Pool lp liquidity
           psC      = poolStateCoin us
           lC       = mkCoin (liquidityCurrency us) $ lpTicker lp
           usVal    = unitValue $ usCoin us
           lpVal    = valueOf cpCoinA cpAmountA <> valueOf cpCoinB cpAmountB <> unitValue psC
           
           lookups  = Constraints.scriptInstanceLookups usInst        <>
                      Constraints.otherScript usScript                <>
                      Constraints.monetaryPolicy (liquidityPolicy us) <>
                      Constraints.unspentOutputs (Map.singleton oref o)
                      
           tx       = Constraints.mustPayToTheScript usDat1 usVal                                <>
                      Constraints.mustPayToTheScript usDat1 lpVal                                <>
                      Constraints.mustForgeValue (unitValue psC <> valueOf LC liquidity)         <>
                      Constraints.mustSpendScriptOutput oref (Redeemer $ PlutusTx.toData $ Create lp)
           
           ledgerTx <- submitTxConstraintsWith lookups tx
           void $ awaitTxConfirmed $ txId ledgerTx
           
     close :: HasBlockchainActions s => Uniswap -> CloseParams -> Contract w s Text ()
     close us CloseParams{..} = do
         ((oref1, o1, lps), (oref2, o2, lp, liquidity)) <- findUniswapFactoryAndPool us clpCoinA clpCoinB
         pkh                                            <- pubKeyHash <$> ownPubKey
         let usInst   = uniswapInstance us
             usScript = uniswapScript us
             usDat    = Factory $ filter (/= lp) lps
             usC      = usCoin us
             psC      = poolStateCoin us
             lC       = mkCoin (liquidityCurrency us) $ lpTicker lp
             usVal    = unitValue usC
             psVal    = unitValue psC
             lVal     = valueOf lC liquidity
             redeemer = Redeemer $ PlutusTx.toData Close
      
      remove :: HasBlockchainActions s => Uniswap -> RemoveParams -> Contract w s Text ()
      remove us RemoveParams{..} = do
          (_, (oref, o, lp, liquidity)) <- findUniswapFactoryAndPool us rpCoinA rpCoinB
          pkh                           <- pubKeyHash <$> ownPubKey
          when (rpDiff
             lookups  = Constraints.scriptInstanceLookups usInst         <>
                        Constraints.otherScript usScript                 <>
                        Constraints.monetaryPolicy (liquidityPolicy us)  <>
                        Constraints.ownPubKeyHash pkh                    <>
                        Constraints.unspentOutputs (Map.singleton oref1 o1 <> Map.singleton oref2 o2)
                        
              tx      = Constraints.mustPayToTheScript usDat usVal          <>
                        Constraints.mustForgeValue (negate $ psVal <> lVal) <>
                        Constraints.mustSpendScriptOutput oref1 redeemer    <>
                        Constraints.mustSpendScriptOutput oref2 redeemer    <>
                        Constraints.mustIncludeDatum (Datum $ PlutusTx.toData $ Pool lp liquidity)
                        
              ledgerTx <- submitTxConstraintsWith lookups tx
              void $ awaitTxConfirmed $ txId ledgerTx
              
              loginfo $ "closed liquidity pool: " ++ show lp
