
{-# LANGUAGE DataKinds                          #-}
{-# LANGUAGE DeriveAnyClass                     #-}
{-# LANGUAGE DerivingStrategies                 #-}
{-# LANGUAGE FlexibleContexts                   #-}
{-# LANGUAGE GeneralizeNewtypeDeriving          #-}
{-# LANGUAGE LambdaCase                         #-}
{-# LANGUAGE MultiParamTypeClasses              #-}
{-# LANGUAGE NoImplicitPrelude                  #-}
{-# LANGUAGE OverloadedStrings                  #-}
{-# LANGUAGE RecordWildCards                    #-}
{-# LANGUAGE ScopedTypeVariables                #-}
{-# LANGUAGE TemplateHaskell                    #-}
{-# LANGUAGE TypeApplications                   #-}
{-# LANGUAGE TypeFamilies                       #-}
{-# LANGUAGE TypeOperators                      #-}

module Plutus.Contracts.Uniswap.OffChain
    ( poolStateCoinFromUniswapCurrency, liquidityCoin
    , CreateParams (..)
    , SwapParams (..)
    , CloseParams (..)
    , RemoveParams (..)
    , AddParams (..)
    , UniswapUserSchema, UserContractState (..)
    , UniswapOwnerSchema
    , start, create, add, remove, close, swap, pools
    , ownerEndpoint, userEndpoints
    ) where
    
 import           Control.Monad                      hiding (fmap)  
 import qualified Data.Map                           as Map
 import           Data.Monoid                        (Last (..))
 import           Data.Proxy                         (Proxy (..))
 import           Data.Text                          (Text, pack)
 import           Data.Void                          (Void)
 import           Ledger                             hiding (singleton)
 import           Ledger.Constraints                 as Constraints
 import qualified Ledger.Typed.Scripts               as Scripts
 import           Playground.Contract
 import           Plutus.Contract                    hiding (when)
 import qualified Plutus.Contract.Currency           as Currency
 import           Plutus.Contracts.Uniswap.OnChain   (mkUniswapValidator, validateLiquidityForging)
 import           Plutus.Contracts.Uniswap.Pool
 import           Plutus.Contracts.Uniswap.Types
 import qualified PlutusTx
 import           PlutusTx.Prelude                    hiding (Semigroup (..), dropWhile, flip, unless)
 import           Prelude                             as Haskell (Int, Semigroup (..), String, div, dropWhile, flip, show,
 
 import           Text.Printf                         (printf)
 
 data Uniswapping
 instance Scripts.ScriptType Uniswapping where
     type instance RedeemerType Uniswapping = UniswapAction
     type instance DatumType    Uniswapping = UniswapDatum
 
 type UniswapOwnerSchema =
     BlockchainActions
         ./\ Endpoint "start" ()
         
 type UniswapUserSchema = 
     BlockchainActions
         .\/ Endpoint "create" CreateParams
         .\/ Endpoint "swap"   SwapParams
         .\/ Endpoint "close"  CloseParams
         .\/ Endpoint "remove" RemoveParams
         .\/ Endpoint "add"    AddParams
         .\/ Endpoint "pools" ()
         .\/ Endpoint "funds" ()
         .\/ Endpoint "stop"  ()
         
-- | Type of the Uniswap user contract state.
data UserContractState =
      Pools [((Coin A, Amount A), (Coin B, AmountB))]
    | Funds Value
    | Created
    | Swapped
    | Added
    | Remove
    | Close
    | Stopped
    deriving (Show, Generic, FromJSON, ToJSON)
    
uniswapTokenName, poolStateTokenName :: TokenName
uniswapTokenName = "Uniswap"
poolStateTokenName = "Pool State"

uniswapInstance :: Uniswap -> Scripts.ScriptInstance Uniswapping
uniswapInstance us = Scripts.validator @Uniswapping
    ($$(PlutusTx.compile [|| mkUniswapValidator ||])
        'PlutusTx.applyCode' PlutusTx.liftCode us
        'PlutusTx.applyCode' PlutusTx.liftCode c)
     $$(PlutusTx.compile [|| wrap ||])
     where
       c :: Coin PoolState
       c = poolStateCoin us
       
       wrap = Scripts.wrapValidator @UniswapDatum @UniswapAction
