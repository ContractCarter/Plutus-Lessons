
import qualified Prelude

--| data type
-- seller public keys, Token, NFT identifying UTxO
data TokenSale = TokenSale 
{ tsSeller :: !PubKeyHash
, tsToken :: !AssetClass
, tsNFT   :: !AssetClass
} deriving (Show, Generic, FromJSON, ToJSON, Prelude.Eq, Prelude.Ord)

PlutusTx.makeLift " "TokenSale 

data TSRedeemer =
      SetPrice Integer          -- price
    | AddTokens Integer.        -- add Tokens
    | BuyTokens Integer         -- buy Tokens
    | Withdraw Integer Integer  -- Withdraw Tokens + lovelaces
    deriving (Show, Prelude.Eq)
    
PlutusTx.unstableMakeIsData " "TSRedeemer

--| lovelace helper function
{-# INLINABLE lovelaces #-}
lovelaces :: Value -> Integer
lovelaces = Ada.getLovelace _ Ada.fromValue

--| Script Address
-- TokenSale parameter holds state machine  config value, Redeemer, a Just constraints holding new state 
-- We must remove the NFT (negate 1) due to Plutus library adding it again
-- mempty needs no constraints meaning anyone can participate 
-- AddTokens Redeemer check seller address return new sate without constraints (no constraints)
-- BuyTokens Redeemer any address can buy tokens 
-- Withdraw Redeemer Tokens and lovelaces in the contract 
{-# INLINABLE transition #-}
transition :: TokenSale -> State Integer -> TSRedeemer -> Maybe (TxConstraints Void Void, State Integer)
transition ts s r = case (stateValue s, stateData s, r) of
    (v, _, SetPrice p)   | p >= 0          -> Just  ( Constraints.mustBeSignedBy (tsSeller ts)
                                                     , State p $
                                                       v <>
                                                       nft (negate 1)
                                                      )
    (v, p, AddTokens n) | n > 0             -> Just ( mempty
                                                       , State p $ v <>
                                                         nft (negate 1) <>                           
                                                         assetClassValue (tsToken ts) n
                                                       )
                                                       
    (v, p, BuyTokens n) | n > 0 -> ( mempty
                                   , State p $
                                     v                                       <>
                                     nft (negate 1)                          <>
                                     assetClassValue (tsToken ts) (negate n) <>
                                     lovelaceValueOf (n * p)
                                    )
                                    
    (v, p, Withdraw n 1) | n >= 0 && 1 >= 0 -> Just ( Constraints.mustBeSignedBy (tsSeller ts)
                                                    , State p $
                                                      v                                      <>
                                                      nft (negate 1)                         <>
                                                      assetClassValueOf (negate 1)
                                                    )
     _                                      -> Nothing
    where
    
    --| helper function to reference NFT
      nft :: Integer -> Value
      nft = assetClassValue (tsNFT ts)
   
   type TS = StateMachine Integer TSRedeemer

tsInst :: TokenSale -> Scripts.ScriptInstance TS
tsInst ts = Scripts.validator @TS
    ($$(PlutusTx.compile [|| mkTSValidator ||]) `PlutusTx.applyCode` PlutusTx.liftCode ts)
    $$(PlutusTx.compile [|| wrap ||])
  where
    wrap = Scripts.wrapValidator @Integer @TSRedeemer

tsValidator :: TokenSale -> Validator
tsValidator = Scripts.validatorScript . tsInst

tsAddress :: TokenSale -> Ledger.Address
tsAddress = scriptAddress . tsValidator

tsClient :: TokenSale -> StateMachineClient Integer TSRedeemer
tsClient ts = mkStateMachineClient $ StateMachineInstance (tsStateMachine ts) (tsInst ts)
                                                       
