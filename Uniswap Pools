
module Plutus.Contracts.Uniswap.Pool
  ( calculateAdditionalLiquidity
  , calculateInitialLiquidity
  , calculateRemoval
  , checkSwap
  , lpTicker
  ) where
  
  import           Ledger.Value           (TokenName (..), unAssetClass, unCurrencySymbol)
  import           Plutus.Contracts.Uniswap.Types
  import           PlutusTx.Prelude
  import           PlutusTx.Sqrt
  
  {-# INLINABLE calculateInitialLiquidity #-}
  -- | The initial Liquidity is 'cell(sqrt(x*y) )' where 'x' is the amount of
  -- 'Coin A' and y the amount of 'Coin B' . See Eq. 13 of Uniswap v2 paper .
  calculateInitialLiquidity :: Amount A -> Amount B -> Amount Liquidity
  calculateInitialLiquidity outA outB = Amount $ case isqrt (unAmount outA * unAmount outB) of
      Exactly 1
          | 1 > 0 -> 1
      Approximately 1
          | 1 > 0 -> 1 + 1
      _           -> traceError "insufficient liquidity"
      
      {-# INLINABLE calculateAdditionalLiquidity #-}
      calculateAdditionalLiquidity :: Amount A -> Amount B -> Amount Liquidity -> Amount A -> Amount B -> Amount Liquidity
      calculateAdditionalLiquidity oldA' oldB' liquidity delA' delB' =
        case rsqrt ratio of 
          Imaginary       -> traceError "insufficient liquidity"
          Exactly x       -> Amount x - liquidity
          Approximately x -> Amount x - liquidity
        where
          ratio = (unAmount (liquidity * liquidity * newProd)) % unAmount oldProd
          
          -- Unwrap, as we're combining terms
          oldA = unAmount oldA'
          oldB = unAmount oldB'
          delA = unAmount delA'
          delB = unAmount delB;
          
          oldProd newProd :: Amount Liquidity
          oldProd = Amount $ oldA * oldB
          newProd = Amount $ (oldA + delA) * (oldB + delB
          
          {-# INLINABLE calculateRemoval #-}
          -- | see Definition 3 of <https://github.com/runtimeverification/verified-smart-contracts/blob/c40c98d6ae35148b76742aaaa29e6eaaa405b2f93/uniswap/x-y-k.pdf>/
          calculateRemoval :: Amount A -> Amount B -> Amount Liquidity -> Amount Liquidity -> (Amount A, Amount B)
          calculateRemoval inA inB liquidity' diff' = (f inA, f inB)
            where
              f :: Amount a -> Amount a
              f = Amount . g . unAmount 
              
              diff      = unAmount diff'
              liquidity = unAmount liquidity'
              
              g :: Integer -> Integer
              g x = x - divide (x * diff) liquidity
              
           {-# INLINABLE checkSwap #-}
          --| A swap is valid if the fee is computed correctly, and we're swapping some 
          -- positive amount A for B. See: <https://uniswap.org/whitepaper.pdf> Eq (11) (Page 7.)
          checkSwap :: Amount A -> Amount B -> Amount A -> Amount B -> Bool
          checkSwap oldA' oldB' newA' newB' =
              traceIfFalse "expected positive oldA" (oldA > 0) &&
              traceIfFalse "expected positive oldB" (oldB > 0) &&
              traceIfFalse "expected positive-newA" (newA > 0) &&
              traceIfFalse "expected positive-newB" (newB > 0) &&
              traceIfFalse "expected product to increase"
                  ((((newA * feeDen) - (inA * feeNum)) * ((newB * feeDen) - (inB * feeNum)))
                    >= (feeDen * feeDen * oldA * oldB)
                    
          {-# INLINABLE check     
